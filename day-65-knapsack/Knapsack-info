The Knapsack Problem is a classic optimization problem in computer science and combinatorial optimization. 
It is often used to illustrate various algorithmic techniques, such as dynamic programming, greedy algorithms, and backtracking. The problem can be described as follows:

Problem Statement
Imagine you have a knapsack (a bag) that can hold a limited weight (capacity). You are given a set of items, 
each with a specific weight and value. The objective is to determine the maximum value that can be carried in the knapsack without exceeding its weight capacity.

Types of Knapsack Problems
0/1 Knapsack Problem:

Each item can either be included in the knapsack (1) or not included (0). You cannot take fractional parts of an item.
Example: If you have items of weights [2, 3, 4] and values [3, 4, 5], and the knapsack capacity is 5, the solution would involve selecting whole items to maximize the total value.
Fractional Knapsack Problem:

You can take fractions of an item. This is typically solved using a greedy approach.
Example: If you have an item with a weight of 10 and a value of 60, and the knapsack can hold 5, you can take half of the item to maximize value.
Unbounded Knapsack Problem:

You can take unlimited quantities of each item. This means you can include the same item multiple times in the knapsack.
Example: If you have items with weights [1, 2, 3] and values [10, 15, 40], and the knapsack capacity is 5, you can take multiple items to achieve the maximum value.
Applications
The knapsack problem has numerous practical applications, including:

Resource Allocation: Allocating limited resources (like budget or time) to maximize returns.
Cargo Loading: Determining how to load cargo into a vehicle to maximize value while adhering to weight limits.
Investment Decisions: Selecting a combination of investments to maximize returns while staying within a budget.
Algorithms
Dynamic Programming: This is commonly used for the 0/1 knapsack problem. It involves breaking the problem into smaller subproblems and storing the results to avoid redundant calculations.

Greedy Algorithms: This approach is used for the fractional knapsack problem, where items are selected based on their value-to-weight ratio.

Backtracking: This method explores all possible combinations of items and is often used for smaller instances of the problem.

Conclusion
The knapsack problem is a fundamental problem in computer science that illustrates the challenges of optimization. It has a wide range of applications and serves as a foundation for understanding more complex algorithms and problem-solving techniques.


-------
Time complexity for Fractional KnapSack

The Fractional Knapsack problem is solved using the Greedy Algorithm, which involves sorting items based on their value-to-weight ratio and taking the most valuable fraction first.

Time Complexity Breakdown
Sorting Items:

We first sort the items based on value/weight ratio in descending order.
Sorting takes O(n log n) time using an efficient sorting algorithm (e.g., Merge Sort, Quick Sort, or Heap Sort).
Selecting Items Greedily:

We iterate through the sorted list and add items (or fractions of them) to the knapsack until it's full.
This step takes O(n) time.
Overall Time Complexity
O(n log n) + O(n) = O(n log n)
The sorting step dominates, so the overall time complexity is O(n log n).
This makes the Fractional Knapsack problem significantly faster than the 0/1 Knapsack problem, which requires O(nW) time using dynamic programming.

